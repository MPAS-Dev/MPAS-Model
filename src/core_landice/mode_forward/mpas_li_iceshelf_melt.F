! Copyright (c) 2013-2018,  Los Alamos National Security, LLC (LANS)
! and the University Corporation for Atmospheric Research (UCAR).
!
! Unless noted otherwise source code is licensed under the BSD license.
! Additional copyright and license information can be found in the LICENSE file
! distributed with this code, or at http://mpas-dev.github.com/license.html
!


!|||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||
!
!  li_iceshelf_melt
!
!> \brief MPAS land ice vertical temperature/enthalpy solver
!> \author William Lipscomb
!> \date   October 2015
!> \details
!>  This module contains solvers for the vertical temperature
!>  and/or enthalpy profile.
!
!-----------------------------------------------------------------------

module li_iceshelf_melt

   use mpas_derived_types
   use mpas_pool_routines
   use mpas_dmpar
   use mpas_timer
   use mpas_abort
   use mpas_log

   use li_setup
   use li_mask
   use li_constants

   implicit none
   private

   !--------------------------------------------------------------------
   !
   ! Public parameters
   !
   !--------------------------------------------------------------------

   !--------------------------------------------------------------------
   !
   ! Public member functions
   !
   !--------------------------------------------------------------------

   public :: li_basal_melt_floating_ice, grounded_face_melt_ismip6

   !--------------------------------------------------------------------
   !
   ! Private module variables
   !
   !--------------------------------------------------------------------

!***********************************************************************
   contains
!***********************************************************************

!|||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||
!
!  !  routine li_basal_melt_floating_ice
!
!> \brief MPAS land ice solver for basal melt of floating ice
!> \author William Lipscomb
!> \date   November 2015
!> \details
!>  This routine computes basal melting for floating ice.
!>  The following options are supported:
!>  (1) Do nothing (config_basal_mass_bal_float = 'none')
!>  (2) Read melt rate from a file (config_basal_mass_bal_float = 'file')
!>  (2) Prescribed constant basal melt rate (config_basal_mass_bal_float = 'constant')
!>  (3) Basal melt rate as in MISMIP+ (config_basal_mass_bal_float = 'mismip')

!-----------------------------------------------------------------------

   subroutine li_basal_melt_floating_ice(domain, err)

      !-----------------------------------------------------------------
      ! input variables
      !-----------------------------------------------------------------

      !-----------------------------------------------------------------
      ! input/output variables
      !-----------------------------------------------------------------
      type (domain_type), intent(inout) :: &
         domain          !< Input/Output: domain object

      !-----------------------------------------------------------------
      ! output variables
      !-----------------------------------------------------------------
      integer, intent(out) :: err !< Output: error flag

      !-----------------------------------------------------------------
      ! local variables
      !-----------------------------------------------------------------

      type (block_type), pointer :: block

      type (mpas_pool_type), pointer :: meshPool
      type (mpas_pool_type), pointer :: geometryPool
      type (mpas_pool_type), pointer :: velocityPool   ! needed for mask subroutine
      type (mpas_pool_type), pointer :: scratchPool

      integer, pointer :: &
           nCellsSolve                 ! number of locally owned cells

      logical, pointer :: &
           config_print_thermal_info   ! if true, print debug info

      character(len=StrKIND), pointer :: &
           config_basal_mass_bal_float ! option for basal mass balance of floating ice

      character(len=StrKIND), pointer :: &
           config_front_mass_bal_grounded ! option for submarine mass balance
                                          ! at grounded glacier front

      real(kind=RKIND), pointer :: &
           config_thermal_thickness, & ! minimum thickness (m) for temperature calculations
           config_sea_level,         & ! sea level (m) relative to z = 0
           config_bmlt_float_flux,   & ! constant heat flux (W/m^2) applied to the base of floating ice; positive upward
           config_bmlt_float_xlimit    ! x value (m) defining region where bmlt_float_flux is applied;
                                       !   melt only where abs(x) > xlimit
      real (kind=RKIND), pointer :: config_ice_density !< ice density

      integer, dimension(:), pointer :: &
           cellMask                    ! bit mask describing whether ice is floating, dynamically active, etc.

      type (field1dInteger), pointer :: thermalCellMaskField

      integer, dimension(:), pointer :: &
           thermalCellMask             ! mask for thermal calculations
                                       ! = 1 where thickness > config_thermal_thickness, elsewhere = 0

      real (kind=RKIND), dimension(:), pointer :: &
           xCell                       ! x coordinate for each cell (m)

      real (kind=RKIND), dimension(:), pointer :: &
           floatingBasalMassBal,     & ! basal mass balance for floating ice
           thickness,                & ! ice thickness (m)
           lowerSurface,             & ! lower surface elevation (m)
           bedTopography               ! bed topography (m; negative below sea level)

      real(kind=RKIND), pointer :: daysSinceStart

      integer :: iCell, err_tmp

      ! Local variables for some melt methods

      real(kind=RKIND) :: &
           bmlt_float_rate                          ! constant basal melt rate (m/s)
                                                    ! = config_bmlt_float_flux / (config_ice_density*latent_heat_ice)
      real(kind=RKIND) :: hCavity               ! depth of ice cavity beneath floating ice (m)
      real(kind=RKIND) :: zDraft                ! draft of floating ice (m below sea level)

      ! basal melting parameters for MISMIP+ experiment
      ! Note: These could be made user-configurable, but are hardwired for now because there are no plans
      !       to run MISMIP+ with different values
      real(kind=RKIND), parameter :: &
           bmlt_float_omega = 0.20_RKIND / scyr,  & ! time scale for basal melting (s^-1)
                                                    ! MISMIP+ default value = 0.2 yr^-1
           bmlt_float_h0 = 75._RKIND,             & ! scale for sub-shelf cavity thickness (m)
                                                    ! MISMIP+ default value = 75 m
           bmlt_float_z0 = -100._RKIND              ! scale for ice draft (m)
                                                    ! MISMIP+ default value = -100 m

      real(kind=RKIND) :: GLdepth, CFdepth ! ice shelf draft stats needed by the temperature_profile method:
                                           ! characteristic grounding line depth, calving front depth


      err = 0
      err_tmp = 0

      call mpas_pool_get_config(liConfigs, 'config_basal_mass_bal_float', config_basal_mass_bal_float)
      call mpas_pool_get_config(liConfigs, 'config_front_mass_bal_grounded', config_front_mass_bal_grounded)
      call mpas_pool_get_config(liConfigs, 'config_print_thermal_info', config_print_thermal_info)

      if (config_print_thermal_info) then
         call mpas_log_write('Solving for basal melting of floating ice, config_basal_mass_bal_float = ' // &
              trim(config_basal_mass_bal_float) )
      endif

      ! Simple options handled here
      if (trim(config_basal_mass_bal_float) == 'none' &
                .and. config_front_mass_bal_grounded == 'none') then

         ! Zero entire field

         ! block loop
         block => domain % blocklist
         do while (associated(block))
            call mpas_pool_get_subpool(block % structs, 'geometry', geometryPool)
            call mpas_pool_get_array(geometryPool, 'floatingBasalMassBal', floatingBasalMassBal)

            floatingBasalMassBal = 0.0_RKIND

            block => block % next
         enddo   ! associated(block)

         return ! skip the rest of this routine

      elseif (trim(config_basal_mass_bal_float) == 'file') then

         return   ! already set; nothing to do

      endif

      ! get rest of config variables
      call mpas_pool_get_config(liConfigs, 'config_thermal_thickness', config_thermal_thickness)
      call mpas_pool_get_config(liConfigs, 'config_sea_level', config_sea_level)
      call mpas_pool_get_config(liConfigs, 'config_bmlt_float_flux', config_bmlt_float_flux)
      call mpas_pool_get_config(liConfigs, 'config_bmlt_float_xlimit', config_bmlt_float_xlimit)
      call mpas_pool_get_config(liConfigs, 'config_ice_density', config_ice_density)

      ! The temp-profile method needs a global reduction before it can operate, so do that here
      ! before the main option block
      if (trim(config_basal_mass_bal_float) == 'temperature_profile') then
         call calc_iceshelf_draft_info(domain, GLdepth, CFdepth, err_tmp)
         err = ior(err, err_tmp)
         if (config_print_thermal_info) then
            call mpas_log_write('GLdepth=$r, CFdepth=$r', realArgs=(/GLdepth, CFdepth/))
         endif
      endif

      if (trim(config_front_mass_bal_grounded) == 'ismip6') then
         call grounded_face_melt_ismip6(domain, err_tmp)
         err = ior(err, err_tmp)

      endif

      if (trim(config_basal_mass_bal_float) == 'ismip6') then
         call iceshelf_melt_ismip6(domain, err_tmp)
         err = ior(err, err_tmp)

         return ! do not enter block loop below - we are done here
      endif
    
      ! block loop
      block => domain % blocklist
      do while (associated(block))

         ! get pools
         call mpas_pool_get_subpool(block % structs, 'mesh', meshPool)
         call mpas_pool_get_subpool(block % structs, 'geometry', geometryPool)
         call mpas_pool_get_subpool(block % structs, 'velocity', velocityPool)
         call mpas_pool_get_subpool(block % structs, 'scratch', scratchPool)

         ! get dimensions
         call mpas_pool_get_dimension(meshPool, 'nCellsSolve', nCellsSolve)

         ! get fields from the mesh pool
         call mpas_pool_get_array(meshPool, 'xCell', xCell)
         call mpas_pool_get_array(meshPool, 'daysSinceStart',daysSinceStart)

         ! get fields from the geometry pool
         call mpas_pool_get_array(geometryPool, 'thickness', thickness)
         call mpas_pool_get_array(geometryPool, 'lowerSurface', lowerSurface)
         call mpas_pool_get_array(geometryPool, 'bedTopography', bedTopography)
         call mpas_pool_get_array(geometryPool, 'cellMask', cellMask)
         call mpas_pool_get_array(geometryPool, 'floatingBasalMassBal', floatingBasalMassBal)

         ! get fields from the scratch pool
         call mpas_pool_get_field(scratchPool, 'iceCellMask', thermalCellMaskField)
         call mpas_allocate_scratch_field(thermalCellMaskField, .true.)
         thermalCellMask => thermalCellMaskField % array

         ! calculate masks - so we know where the ice is floating
         call li_calculate_mask(meshPool, velocityPool, geometryPool, err_tmp)
         err = ior(err, err_tmp)

         ! calculate a mask to identify ice that is thick enough to be thermally active
         do iCell = 1, nCellsSolve
            if (thickness(iCell) > config_thermal_thickness) then
               thermalCellMask(iCell) = 1
            else
               thermalCellMask(iCell) = 0
            endif
         enddo

         ! -----------------
         ! Compute basal melting for floating ice.
         ! -----------------

         ! initialize to zero melt
         floatingBasalMassBal(:) = 0.0_RKIND
         if (trim(config_basal_mass_bal_float) == 'none') then
            ! Do nothing, handled above

         elseif (trim(config_basal_mass_bal_float) == 'file') then
            ! Do nothing, handled above

         elseif (trim(config_basal_mass_bal_float) == 'constant') then

            ! set melt rate to a constant value for floating ice
            ! allow basal melt in ice-free ocean cells, in case ice is advected to those cells by the transport scheme

            bmlt_float_rate = config_bmlt_float_flux / (config_ice_density*latent_heat_ice)  ! convert W/m^2 to m/s

            floatingBasalMassBal(:) = 0.0_RKIND

            do iCell = 1, nCellsSolve
               if ( (li_mask_is_floating_ice(cellMask(iCell))) .or.  &
                    (bedTopography(iCell) < config_sea_level .and. thermalCellMask(iCell) == 0) ) then
                  ! ice is present and floating, or ice-free ocean

                  ! Provided xCell > bmlt_float_xlimit, prescribe a uniform basal melt rate.
                  ! The default is 0.0, but for MISMIP+ the prescribed value of xlimit is 480 km.
                  if (abs(xCell(iCell)) >= config_bmlt_float_xlimit) then  ! basal melting is allowed
                     floatingBasalMassBal(iCell) = -bmlt_float_rate
                  endif

               endif   ! ice is present and floating

            enddo   ! iCell

            ! change units from m/s to kg/m2/s
            floatingBasalMassBal(:) = floatingBasalMassBal(:) * config_ice_density

         elseif (trim(config_basal_mass_bal_float) == 'mismip') then

            ! compute melt rate (m/s) based on bed depth and cavity thickness
            ! The MISMIP+ formula is as follows:
            !
            ! bmlt_float = omega * tanh(H_c/H_0) * max(z_0 - z_d, 0)
            !
            ! where H_c = lsrf - topg is the cavity thickness
            !       z_d = lsrf - eus is the ice draft
            !       omega = a time scale = 0.2 yr^{-1} by default
            !       H_0 = 75 m by default
            !       z_0 = -100 m by default

            ! allow basal melt in ice-free ocean cells, in case ice is advected to those cells by the transport scheme

            floatingBasalMassBal(:) = 0.0_RKIND

            do iCell = 1, nCellsSolve

               if ( (li_mask_is_floating_ice(cellMask(iCell))) .or.  &
                    (bedTopography(iCell) < config_sea_level .and. thermalCellMask(iCell) == 0) ) then
                    ! ice is present and floating, or ice-free ocean

                  hCavity = lowerSurface(iCell) - bedTopography(iCell)
                  zDraft = lowerSurface(iCell) - config_sea_level
                  floatingBasalMassBal(iCell) = -bmlt_float_omega * tanh(hCavity/bmlt_float_h0) * max(bmlt_float_z0 - &
                     zDraft, 0.0_RKIND)

               endif   ! ice is present and floating
            enddo   ! iCell

            ! change units from m/s to kg/m2/s
            floatingBasalMassBal(:) = floatingBasalMassBal(:) * config_ice_density

         elseif (trim(config_basal_mass_bal_float) == 'seroussi') then

            call basal_melt_thwaites_seroussi(floatingBasalMassBal, daysSinceStart, lowerSurface, cellMask, &
                    config_sea_level, config_ice_density, nCellsSolve, err_tmp)
            err = ior(err, err_tmp)

         elseif (trim(config_basal_mass_bal_float) == 'temperature_profile') then

            call iceshelf_melt_param_from_temp_profile(nCellsSolve, lowerSurface, cellMask, &
                    config_sea_level, config_ice_density, config_print_thermal_info, &
                    GLdepth, CFdepth, daysSinceStart, floatingBasalMassBal, err_tmp)
            err = ior(err, err_tmp)

         else

            call mpas_log_write('Unknown option selected for config_basal_mass_bal_float:' // &
               trim(config_basal_mass_bal_float), MPAS_LOG_ERR)
            err = ior(err, 1)

         endif   ! config_basal_mass_bal_float


         ! clean up
         call mpas_deallocate_scratch_field(thermalCellMaskField, .true.)

         block => block % next
      enddo   ! associated(block)


    end subroutine li_basal_melt_floating_ice
!-----------------------------------------------------------------------


!***********************************************************************
!***********************************************************************
! Private subroutines:
!***********************************************************************
!***********************************************************************



!|||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||
!
!  !  routine basal_melt_thwaites_seroussi
!
!> \brief Calculate ice shelf melt rate from depth param.
!> \author William Lipscomb
!> \date   November 2015
!> \details
!>  Melt rate parameterization from:
!> Seroussi, H., Y. Nakayama, E. Larour, D. Menemenlis, M. Morlighem, E. Rignot, and A. Khazendar (2017),
!> Continued retreat of Thwaites Glacier, West Antarctica, controlled by bed topography and ocean circulation,
!> Geophys. Res. Lett., 1-9, doi:10.1002/2017GL072910.
!> for Thwaites Glacier.
!> Specifically, this is a linear fit of melt with shelf draft from the Supplemental Information, Figure S1.
!> The linear relation is modified by a:
!>   * depth above which there is no melt (Antarctic Surface Water saturation)
!>   * a maximum melt rate (Circumpolar Deep Water saturation)
!>   * a depth below which melt stops increasing (minimum sill height)

!-----------------------------------------------------------------------

    subroutine basal_melt_thwaites_seroussi(floatingBasalMassBal, daysSinceStart, lowerSurface, cellMask, &
                    config_sea_level, config_ice_density, nCellsSolve, err)

      !-----------------------------------------------------------------
      ! input variables
      !-----------------------------------------------------------------
      real(kind=RKIND), pointer, intent(in) :: daysSinceStart
      real (kind=RKIND), dimension(:), pointer, intent(in) :: lowerSurface  !< lower surface elevation (m)
      integer, dimension(:), pointer, intent(in) :: &
           cellMask                    !< bit mask describing whether ice is floating, dynamically active, etc.
      real(kind=RKIND), pointer, intent(in) :: &
           config_sea_level !< sea level (m) relative to z = 0
      real (kind=RKIND), pointer, intent(in) :: config_ice_density !< ice density
      integer, pointer :: &
           nCellsSolve                 !< number of locally owned cells

      !-----------------------------------------------------------------
      ! input/output variables
      !-----------------------------------------------------------------

      !-----------------------------------------------------------------
      ! output variables
      !-----------------------------------------------------------------
      real (kind=RKIND), dimension(:), pointer, intent(out) :: &
           floatingBasalMassBal      !< basal mass balance for floating ice
      integer, intent(out) :: err !< Output: error flag

      !-----------------------------------------------------------------
      ! local variables
      !-----------------------------------------------------------------
      real (kind=RKIND) :: slopeSer  ! slope of relation between depth and melt rate
      real (kind=RKIND) :: interceptSer  ! depth at which melting goes to 0
      real (kind=RKIND) :: maxMeltSer  ! maximum allowable melt rate
      real (kind=RKIND) :: sillDepth  ! depth below which melt rate no longer increases
      real (kind=RKIND), pointer :: config_basal_mass_bal_seroussi_amplitude
      real (kind=RKIND), pointer :: config_basal_mass_bal_seroussi_period
      real (kind=RKIND), pointer :: config_basal_mass_bal_seroussi_phase
      real(kind=RKIND) :: hCavity               ! depth of ice cavity beneath floating ice (m)
      real(kind=RKIND) :: zDraft                ! draft of floating ice (m below sea level)
      integer :: iCell


      err = 0

      call mpas_pool_get_config(liConfigs, 'config_basal_mass_bal_seroussi_amplitude', &
         config_basal_mass_bal_seroussi_amplitude) ! meters
      call mpas_pool_get_config(liConfigs, 'config_basal_mass_bal_seroussi_period', &
         config_basal_mass_bal_seroussi_period) ! years
      call mpas_pool_get_config(liConfigs, 'config_basal_mass_bal_seroussi_phase', &
         config_basal_mass_bal_seroussi_phase) ! cycles

      slopeSer = 0.088_RKIND ! slope of relation between depth and melt rate (melt (m/yr) per depth (m))
      interceptSer = -100.0_RKIND  ! depth (m) at which melting goes to 0 (negative meaning below sea level)
      maxMeltSer = 50.0_RKIND ! maximum allowable melt rate (m/yr) (positive meaning melting)
      sillDepth = -650.0_RKIND ! depth below which melt stops increasing (m) (negative meaning below sea level)

      if (config_basal_mass_bal_seroussi_period <= 0.0_RKIND) then
         call mpas_log_write("Value for config_basal_mass_bal_seroussi_period has to be a positive real value.", MPAS_LOG_ERR)
         err = ior(err, 1)
      endif

      ! Modify intercept height for variability parameters
      interceptSer = interceptSer + config_basal_mass_bal_seroussi_amplitude * &
              sin( (2.0_RKIND * pii / config_basal_mass_bal_seroussi_period) * (daysSinceStart/365.0_RKIND) &
                  + 2.0_RKIND * pii * config_basal_mass_bal_seroussi_phase)

      ! Initialize before computing
      floatingBasalMassBal(:) = 0.0_RKIND

      do iCell = 1, nCellsSolve

         ! Shut off melt at an arbitrary shallow depth to discourage ice from disappearing.
         if ( (li_mask_is_floating_ice(cellMask(iCell))) .and. (lowerSurface(iCell) < -10.0_RKIND) ) then
            ! ice is present and floating

            zDraft = lowerSurface(iCell) - config_sea_level
            ! Coefficients for m/yr melt rate (in units of Seroussi figure but without negative meaning melting)
            floatingBasalMassBal(iCell) = max(-1.0_RKIND * maxMeltSer, min(0.0_RKIND, slopeSer * &
               (max(zDraft, sillDepth) - interceptSer)))

         endif   ! ice is present
      enddo   ! iCell

      ! change units from m/yr to kg/m2/s
      floatingBasalMassBal(:) = floatingBasalMassBal(:) * config_ice_density / scyr


    end subroutine basal_melt_thwaites_seroussi
!-----------------------------------------------------------------------


!|||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||
!
!  !  routine iceshelf_melt_param_from_temp_profile
!
!> \brief Calculate ice shelf melt rate using parameterization based on ocean temperature profile
!> \author Matthew Hoffman, based on parameterization developed by Xylar Asay-Davis
!> \date   October 2018
!> \details  Melt rate parameterization by Xylar Asay-Davis used in Thwaites variability paper
!> in prep. by Hoffman et al.
!> Parameterization takes a ocean temperature profile and sill depth as input.
!> The temp. profile is adjusted for cavity temperature behind the sill,
!> assuming constant temp. below the sill depth.
!> Then a local temp profile in the boundary layer is estimated assuming exponential
!> decay from the cavity profile to a plume profile at infinite distance downstream
!> from the grounding line, accounting for the pressure-melt temperature.
!> The melt rate is calculated as proportional to the  product of the boundary layer
!> temperature profile and the mean cavity temperature.
!-----------------------------------------------------------------------

    subroutine iceshelf_melt_param_from_temp_profile(nCellsSolve, lowerSurface, cellMask, &
                    config_sea_level, config_ice_density, print_debug, zGL, zCavityMax, daysSinceStart, floatingBasalMassBal, err)

      !-----------------------------------------------------------------
      ! input variables
      !-----------------------------------------------------------------
      integer, intent(in) :: nCellsSolve !< number of locally owned cells
      real (kind=RKIND), dimension(:), intent(in) :: lowerSurface !< ice shelf draft
      integer, dimension(:), intent(in) :: cellMask !< bitmask on cells
      real (kind=RKIND), intent(in) :: config_sea_level, config_ice_density
      logical, intent(in) :: print_debug
      real(kind=RKIND), intent(in) :: zGL, &  !< mean grounding line elevation (m),
                                              !< it's a scalar now, but eventually may want smoothed spatial field
                                      zCavityMax !< depth below which mean thermal forcing is averaged
      real(kind=RKIND), pointer, intent(in) :: daysSinceStart

      !-----------------------------------------------------------------
      ! output variables
      !-----------------------------------------------------------------
      real (kind=RKIND), dimension(:), intent(out) :: floatingBasalMassBal !< BMB for ice shelves
      integer, intent(out) :: err


      !-----------------------------------------------------------------
      ! local variables
      !-----------------------------------------------------------------

      ! parameters for param.
      real(kind=RKIND), pointer :: slopeDraft !< characteristic slope of ice shelf draft
      real(kind=RKIND), pointer :: plumeThickness !< characteristic plume thickness (m)
      real(kind=RKIND), parameter :: E0 = 0.036_RKIND !< entrainment parameter (Jenkins 1991)
      real(kind=RKIND), parameter :: Stanton = 5.9e-4_RKIND !< Stanton number (Jenkins et al. 2010)

      ! All depths are written as elevation relative to sea level (negative values)
      ! variables describing regional profile
      real(kind=RKIND), pointer :: zThermoclineTopBase
         !< depth at top of thermocline (temp assumed constant above this), before variability adjustment
      real(kind=RKIND), pointer :: zThermoclineBotBase
         !< depth at bottom of thermocline (temp assumed constant below this), before variability adjustment
      real(kind=RKIND) :: zThermoclineTop
         !< depth at top of thermocline (temp assumed constant above this), after variability adjustment
      real(kind=RKIND) :: zThermoclineBot
         !< depth at bottom of thermocline (temp assumed constant below this), after variability adjustment
      real(kind=RKIND), pointer :: TThermoclineTop !< temperature at top of thermocline (constant shallow water mass temp.)
      real(kind=RKIND), pointer :: TThermoclineBot !< temperature at bottom of thermocline (constant deep water mass temp.)

      real(kind=RKIND), pointer :: variabilityAmplitude !< amplitude in optional sinusoidal variab. applied to thermocline depths
      real(kind=RKIND), pointer :: variabilityPeriod !< period in optional sinusoidal variability applied to thermocline depths
      real(kind=RKIND), pointer :: variabilityPhase !< phase in optional sinusoidal variability applied to thermocline depths
      real(kind=RKIND) :: depthOffset !< depth offset in thermocline depths due to variability

      ! variables that are general to any depth
      real(kind=RKIND), pointer :: zSill !< sill depth
      real(kind=RKIND) :: TSill !< temperature at the sill depth
      real(kind=RKIND) :: TGL !< temperature at grounding line depth
      real(kind=RKIND) :: TFmean !< mean thermal forcing within the cavity
      real(kind=RKIND), pointer :: kappa !< constant for non-local, quadratic melt param.
      ! variables specific to a given depth
      real(kind=RKIND) :: draft !< elevation of ice shelf draft (m)
      real(kind=RKIND) :: Tregional !< regional temperature at given depth (comes from imposed profile)
      real(kind=RKIND) :: Tcavity !< temperature in cavity at given depth
      real(kind=RKIND) :: Tfreeze !< freezing temperature at given depth
      real(kind=RKIND) :: Tinfinity !< limit of exponential decay of T at given depth
      real(kind=RKIND) :: Tplume !< temperature in plume at a given depth
      real(kind=RKIND) :: zeta !< length scale of decay of plume temperature

      ! other
      integer :: nLevels
      integer :: iCell, z
      real(kind=RKIND) :: zr

      err = 0

      ! get namelist options
      call mpas_pool_get_config(liConfigs, 'config_temperature_profile_melt_scale_factor', kappa)
      call mpas_pool_get_config(liConfigs, 'config_temperature_profile_sill_elevation', zSill)
      call mpas_pool_get_config(liConfigs, 'config_temperature_profile_plume_thickness', plumeThickness)
      call mpas_pool_get_config(liConfigs, 'config_temperature_profile_draft_slope', slopeDraft)
      ! Get temp. profile parameters
      call mpas_pool_get_config(liConfigs, 'config_temperature_profile_thermocline_upper_depth', zThermoclineTopBase)
      call mpas_pool_get_config(liConfigs, 'config_temperature_profile_thermocline_upper_temp', TThermoclineTop)
      call mpas_pool_get_config(liConfigs, 'config_temperature_profile_thermocline_lower_depth', zThermoclineBotBase)
      call mpas_pool_get_config(liConfigs, 'config_temperature_profile_thermocline_lower_temp', TThermoclineBot)
      ! Get variability parameters
      call mpas_pool_get_config(liConfigs, 'config_temperature_profile_variability_amplitude', variabilityAmplitude)
      call mpas_pool_get_config(liConfigs, 'config_temperature_profile_variability_period', variabilityPeriod)
      call mpas_pool_get_config(liConfigs, 'config_temperature_profile_variability_phase', variabilityPhase)


      ! Account for variability in thermocline depth
      if (variabilityPeriod <= 0.0_RKIND) then
         call mpas_log_write("Value for config_temperature_profile_variability_period must be a positive real value.", &
                 MPAS_LOG_ERR)
         err = ior(err, 1)
      endif
      depthOffset = variabilityAmplitude * sin( (2.0_RKIND * pii / variabilityPeriod) * (daysSinceStart/365.0_RKIND) &
                    + 2.0_RKIND * pii * variabilityPhase)
      zThermoclineTop = zThermoclineTopBase + depthOffset
      zThermoclineBot = zThermoclineBotBase + depthOffset

      ! Calculate variables independent of depth
      zeta = slopeDraft * plumeThickness / (E0 * slopeDraft + Stanton)

      ! calculate temperature at sill
      if (zSill >= zThermoclineTop) then
         TSill = TThermoclineTop
      elseif (zSill <= zThermoclineBot) then
         TSill = TThermoclineBot
      else
         TSill = (TThermoclineTop - TThermoclineBot) * &
                 (zSill - zThermoclineBot) / (zThermoclineTop - zThermoclineBot) + TThermoclineBot
      endif
      if (print_debug) then
         call mpas_log_write("kappa=$r, plumeThickness=$r, slopeDraft=$r, zeta=$r", realArgs=(/kappa, plumeThickness, &
                 slopeDraft, zeta/))
         call mpas_log_write("TSill=$r at zSill=$r", realArgs=(/TSill, zSill/))
      endif

      ! calculate temperature at GL (allowing for no sill - sill deeper than GL depth)
      if (zGL < zSill) then
         TGL = TSill
      elseif (zGL >= zThermoclineTop) then
         TGL = TThermoclineTop
      elseif (zGL <= zThermoclineBot) then
         TGL = TThermoclineBot
      else
         TGL = (TThermoclineTop - TThermoclineBot) * &
                 (zGL - zThermoclineBot) / (zThermoclineTop - zThermoclineBot) + TThermoclineBot
      endif
      if (print_debug) then
         call mpas_log_write("TGL=$r at zGL=$r", realArgs=(/TGL, zGL/))
      endif

      ! Need to calculate a mean thermal forcing within the plume
      ! Ideally this would be a function of the ice shelf hypsometry,
      ! but for simplicity calculate assuming a linear (ramp) ice shelf shape.
      ! Average between the GL depth and an arbitrary ice shelf thickness at calving front.
      ! (We think that is better than averaging all the way to surface, even if that thin
      !  shelf thickness does not match that of the modeled ice shelf.)
      TFmean = 0.0_RKIND
      nLevels = 0
      do z = ceiling(zGL), floor(zCavityMax), 1 ! Discretize in 1 m increments
         zr = real(z, kind=RKIND) ! convert once to real data type
         nLevels = nLevels + 1
         ! calculate Tcavity for this depth (allowing for no sill - sill deeper than GL depth)
         if (zr < zSill) then
            Tcavity = TSill
         elseif (zr >= zThermoclineTop) then
            Tcavity = TThermoclineTop
         elseif (zr <= zThermoclineBot) then
            Tcavity = TThermoclineBot
         else
            Tcavity = (TThermoclineTop - TThermoclineBot) * &
                 (zr - zThermoclineBot) / (zThermoclineTop - zThermoclineBot) + TThermoclineBot
         endif
         ! calculate Tfreeze for this depth
         Tfreeze = ocean_freezing_temperature(zr)
         ! calculate Tinfinity for this depth
         Tinfinity = (E0 * slopeDraft * Tcavity + Stanton * Tfreeze) / (E0 * slopeDraft + Stanton)
         ! calculate Tplume for this depth
         Tplume = Tinfinity + (TGL - Tinfinity) * exp(min(-1.0_RKIND * (zr - zGL) / zeta, 0.0_RKIND))
         ! now add to sum of TFmean
         TFmean = TFmean + (Tplume - Tfreeze)
      enddo
      ! now find the average
      if (nLevels > 0) then
         TFmean = TFmean / real(nLevels, kind=RKIND)
      else
         call mpas_log_write("iceshelf_melt_param_from_temp_profile found 0 levels over which to average mean thermal forcing!",&
               MPAS_LOG_ERR)
         err = ior(err, 1)
      endif
      if (print_debug) then
         call mpas_log_write("TFmean=$r", realArgs=(/TFmean/))
      endif

      ! Now calculate melt rate at each grid cell
      do iCell = 1, nCellsSolve
         if (li_mask_is_floating_ice(cellMask(iCell))) then
            if (lowerSurface(iCell) > -20.0_RKIND) then
               ! Shut off melt at an arbitrary shallow depth to prevent ice from melting out entirely
               floatingBasalMassBal(iCell) = 0.0_RKIND
            else
               ! Calculate melt rate here
               draft = lowerSurface(iCell) - config_sea_level
               ! calculate Tcavity for this depth (allowing for no sill - sill deeper than GL depth)
               if (draft < zSill) then
                  Tcavity = TSill
               elseif (draft >= zThermoclineTop) then
                  Tcavity = TThermoclineTop
               elseif (draft <= zThermoclineBot) then
                  Tcavity = TThermoclineBot
               else
                  Tcavity = (TThermoclineTop - TThermoclineBot) * &
                       (draft - zThermoclineBot) / (zThermoclineTop - zThermoclineBot) + TThermoclineBot
               endif
               ! calculate Tfreeze for this depth
               Tfreeze = ocean_freezing_temperature(draft)
               ! calculate Tinfinity for this depth
               Tinfinity = (E0 * slopeDraft * Tcavity + Stanton * Tfreeze) / (E0 * slopeDraft + Stanton)
               ! calculate Tplume for this depth
               Tplume = Tinfinity + (TGL - Tinfinity) * exp(min(-1.0_RKIND * (draft - zGL) / zeta, 0.0_RKIND))
               ! now add to sum of TFmean
               floatingBasalMassBal(iCell) = kappa * TFmean * (Tplume - Tfreeze) ! in m/yr, +=melting
               !floatingBasalMassBal(iCell) = Tplume
            endif
         else ! not floating
            floatingBasalMassBal(iCell) = 0.0_RKIND
         endif
      enddo
      floatingBasalMassBal(:) = floatingBasalMassBal(:) * (-1.0_RKIND) * config_ice_density / scyr ! convert to BMB

    end subroutine iceshelf_melt_param_from_temp_profile
!-----------------------------------------------------------------------


    function ocean_freezing_temperature(depth) result(temp)
      real(kind=RKIND), intent(in) :: depth
      real(kind=RKIND), parameter :: Sref = 34.4_RKIND  !< Reference salinity (made up, typical for MISOMIP1)
      real(kind=RKIND) :: temp

      ! function to calculate freezing temperature from Jenkins (1991)
      temp = 0.0901_RKIND - 0.0575_RKIND * SRef + 7.61e-4_RKIND * depth

    end function ocean_freezing_temperature
!-----------------------------------------------------------------------


!|||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||
!
!  !  routine calc_iceshelf_draft_info
!
!> \brief Calculate characteristic grounding line and calving front depths underneath ice shelves
!> \author Matthew Hoffman
!> \date   October 2018
!> \details Grounding line and calving front depths are used by the
!> temperature_profile iceshelf melt method, but must be calculated before the
!> method is called because they require a global reduce.
!> Different options for how to calculated these depths could be implemented.
!> For the GL depth, an approximation of the mean depth of deepest specified-fraction of the
!> grounding line is used.  For the CF depth, the mean of the calving front
!> is used.
!-----------------------------------------------------------------------

    subroutine calc_iceshelf_draft_info(domain, GLdepth, CFdepth, err)

      !-----------------------------------------------------------------
      ! input variables
      !-----------------------------------------------------------------
      type (domain_type), intent(inout) :: &
         domain          !< Input/Output: domain object

      !-----------------------------------------------------------------
      ! output variables
      !-----------------------------------------------------------------
      real (kind=RKIND), intent(out) :: GLdepth !< mean grounding line depth
      real (kind=RKIND), intent(out) :: CFdepth !< mean calving front depth
      integer, intent(out) :: err

      !-----------------------------------------------------------------
      ! local variables
      !-----------------------------------------------------------------
      type (block_type), pointer :: block

      type (mpas_pool_type), pointer :: meshPool
      type (mpas_pool_type), pointer :: geometryPool

      integer, pointer :: &
           nCellsSolve                 ! number of locally owned cells

      logical, pointer :: &
           config_print_thermal_info   ! if true, print debug info

      real(kind=RKIND), pointer :: &
           config_sea_level ! sea level (m) relative to z = 0

      integer, dimension(:), pointer :: &
           cellMask                    ! bit mask describing whether ice is floating, dynamically active, etc.

      real (kind=RKIND), dimension(:), pointer :: lowerSurface ! lower surface elevation (m)

      real (kind=RKIND), dimension(:), pointer :: areaCell ! cell area (m^2)
      integer, dimension(:), pointer :: nEdgesOnCell
      integer, dimension(:,:), pointer :: cellsOnCell

      real(kind=RKIND) :: sumCFdepth, sumCFarea
      integer :: iCell, jCell
      real(kind=RKIND), dimension(2) :: localCFSums, globalCFSums ! Vars for CF global reduction

      real(kind=RKIND), parameter :: binWidth = 10.0_RKIND !< width of depth bins in meters
      real(kind=RKIND), parameter :: binMinimum = -4000.0_RKIND !< depth of bottom of deepest bin in meters
      integer, parameter :: nBinsMax = 500 !< Maximum possible number of bins - needs to be set to cover the range
                                        !< defined by the previous two variables and sea level (which is run-time configurable)
      integer :: nBins !< number of bins - calculated below
      real(kind=RKIND), dimension(nBinsMax) :: binDepth !< depth in m at bottom of each bin
      real(kind=RKIND), dimension(nBinsMax) :: binWeightSum !< sum of cell weights in this bin
      real(kind=RKIND), dimension(nBinsMax) :: binWeightedDepthSum !< weighted-depth sum over cells in this bin
      real(kind=RKIND), dimension(2*nBinsMax) :: localGLSums, globalGLSums ! Vars for GL global reduction
      real(kind=RKIND) :: cumBinWeightedDepthSum, cumBinWeightSum !< cumulative sums over bins for final calculation
      real(kind=RKIND) :: totalBinWeight !< sum of weights in all bins
      real(kind=RKIND), pointer :: weightThreshold !< fraction of deepest GL depths to average overn

      integer :: indexBin


      err = 0

      call mpas_pool_get_config(liConfigs, 'config_temperature_profile_GL_depth_fraction', weightThreshold)

      ! need to first determine bin info (could happen on init, but cheap to recompute each timestep)
      call mpas_pool_get_config(liConfigs, 'config_sea_level', config_sea_level)
      nBins = ceiling((config_sea_level - binMinimum) / binWidth)  ! round up
      do indexBin = 1, nBins
         binDepth = binMinimum + real(indexBin-1, kind=RKIND) * binWidth ! calc. lower limit of each bin
      enddo

      ! Calculate average GL and CF depths on this processor, looping over blocks.
      ! Note that these are somewhat approximate calculations.
      ! Note that the GL in cellMask includes grounded cells next to open ocean,
      ! which we do NOT want included, so instead we here identify the GL depth at
      ! cells that are floating and have a grounded neighbor.
      ! (Also, the GL cell mask identifies the last grounded cell, not the first floating cell,
      ! which also isn't what we want.)
      ! Also, ideally the weighted average for GL and CF depths would be weighted
      ! based on GL and CF lengths.  That is substantially more work for little
      ! expected improvement (and we would have to make a decision about what elevation to
      ! assign to edges), so I instead use cell area weighted averages.
      ! The GL and CF depths do not need to be highly accurate, so these approximations
      ! are assumed to be fine.
      binWeightSum(:) = 0.0_RKIND
      binWeightedDepthSum(:) = 0.0_RKIND
      sumCFdepth = 0.0_RKIND
      sumCFarea = 0.0_RKIND
      ! init bins for GL calcs
      ! block loop
      block => domain % blocklist
      do while (associated(block))
         call mpas_pool_get_subpool(block % structs, 'geometry', geometryPool)
         call mpas_pool_get_subpool(block % structs, 'mesh', meshPool)
         call mpas_pool_get_array(geometryPool, 'lowerSurface', lowerSurface)
         call mpas_pool_get_array(geometryPool, 'cellMask', cellMask)
         call mpas_pool_get_array(meshPool, 'nEdgesOnCell', nEdgesOnCell)
         call mpas_pool_get_array(meshPool, 'cellsOnCell', cellsOnCell)
         call mpas_pool_get_array(meshPool, 'areaCell', areaCell)
         call mpas_pool_get_dimension(meshPool, 'nCellsSolve', nCellsSolve)

         do iCell = 1, nCellsSolve
            ! First calc. GL stat
            if (li_mask_is_floating_ice(cellMask(iCell)) .and. li_mask_is_dynamic_ice(cellMask(iCell))) then
               ! See if a neighbor is grounded ice
               do jCell = 1, nEdgesOnCell(iCell)
                  if (li_mask_is_grounded_ice(cellMask(cellsOnCell(jCell, iCell)))) then ! we found the first floating cell
                     ! check for reasonable values first
                     if (lowerSurface(iCell) < binMinimum) then
                        call mpas_log_write("calc_iceshelf_draft_info found a grounding line depth below the minimum search " // &
                              "depth of $r.  Adjust binMinimum and related parameters and recompile.", &
                              MPAS_LOG_ERR, realArgs = (/binMinimum/))
                        err = ior(err, 1)
                        return
                     elseif (lowerSurface(iCell) > config_sea_level) then
                        call mpas_log_write("calc_iceshelf_draft_info found a grounding line depth above sea level."&
                                // "  Adjust hard-coded parameters and recompile.", MPAS_LOG_ERR)
                        err = ior(err, 1)
                        return
                     endif
                     ! Find which bin this location falls in
                     indexBin = floor((lowerSurface(iCell) - binMinimum) / binWidth) + 1


                     ! Use the sqrt of cell area as the weighting function (it should be a linear measure, not an area measure)
                     binWeightedDepthSum(indexBin) = binWeightedDepthSum(indexBin) + lowerSurface(iCell) * sqrt(areaCell(iCell))
                     binWeightSum(indexBin) = binWeightSum(indexBin) + sqrt(areaCell(iCell))
                     !call mpas_log_write("GL cell: $i, $r, $r", intArgs=(/iCell/), &
                     !realArgs=(/lowerSurface(iCell), areaCell(iCell)/))
                     exit  ! skip the rest of the loop around neighbors
                  endif
               enddo
            endif
            ! Now calc. CF stat
            if (li_mask_is_floating_ice(cellMask(iCell)) .and. li_mask_is_dynamic_margin(cellMask(iCell))) then
               ! accumulate area-weighted CF depth and area
               sumCFdepth = sumCFdepth + lowerSurface(iCell) * areaCell(iCell)
               sumCFarea = sumCFarea + areaCell(iCell)
            endif
         enddo

         block => block % next
      enddo   ! associated(block)

      ! --- Global reduction for GL stat ---
      ! pack communication array
      localGLSums(1:nBins) = binWeightedDepthSum(1:nBins)
      localGLSums(nBins+1:2*nBins) = binWeightSum(1:nBins)
      ! global reduction
      call mpas_dmpar_sum_real_array(domain % dminfo, 2*nBins, localGLSums(:), globalGLSums(:))
      ! unpack communication array
      binWeightedDepthSum(1:nBins) = globalGLSums(1:nBins)
      binWeightSum(1:nBins) = globalGLSums(nBins+1:2*nBins)
      ! sum up through bins until threshold is reached
      totalBinWeight = sum(binWeightSum(1:nBins))
      if (totalBinweight > 0.0_RKIND) then
         cumBinWeightedDepthSum = 0.0_RKIND
         cumBinWeightSum = 0.0_RKIND
         do indexBin = 1, nBins
            cumBinWeightedDepthSum = cumBinWeightedDepthSum + binWeightedDepthSum(indexBin)
            cumBinWeightSum = cumBinWeightSum + binWeightSum(indexBin)
            ! check if we've reached threshold
            if (cumBinWeightSum / totalBinweight > weightThreshold) then
               ! We reached the desired threshold of deepest samples.  Make final calculation and quit.
               GLdepth = cumBinWeightedDepthSum / cumBinWeightSum
               exit  ! skip the rest of the loop over bins
            endif
         enddo
      else
              ! Most likely situation: no GL!  So do nothing.
      endif

      ! --- Global reduction for CF stat ---
      localCFSums = (/sumCFdepth, sumCFarea/)
      ! sum up over all procs
      call mpas_dmpar_sum_real_array(domain % dminfo, 2, localCFSums(:), globalCFSums(:))
      if (globalCFSums(2) > 0.0_RKIND) then
         CFdepth = globalCFSums(1) / globalCFSums(2)
      else
         CFdepth = 0.0_RKIND
      endif

    end subroutine calc_iceshelf_draft_info
!-----------------------------------------------------------------------


!|||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||
!
!  !  routine iceshelf_melt_ismip6
!
!> \brief Calculate ice shelf melt rate using parameterization from ISMIP6
!> \author Matthew Hoffman
!> \date   July 2019
!> \details
!> http://www.climate-cryosphere.org/wiki/index.php?title=ISMIP6-Projections-Antarctica
!> It is a quadratic method of the form:
!> melt = gamma * physicalconstant * (TF(x,z,y_draft) + deltaT_basin) * |<TF> + deltatT_basin|
!> where TF is local thermal forcing at each grid cell and <TF> is the mean
!> thermal forcing for all of the ice shelf grid cells in an entire basin
!-----------------------------------------------------------------------

    subroutine iceshelf_melt_ismip6(domain, err)

      !-----------------------------------------------------------------
      ! input/output variables
      !-----------------------------------------------------------------
      type (domain_type), intent(inout) :: &
         domain          !< Input/Output: domain object

      !-----------------------------------------------------------------
      ! output variables
      !-----------------------------------------------------------------
      integer, intent(out) :: err


      !-----------------------------------------------------------------
      ! local variables
      !-----------------------------------------------------------------
      integer :: iCell
      integer, pointer :: nOceanLayers
      integer :: ksup, kk, kinf
      integer, pointer :: nCellsSolve
      real(kind=RKIND), pointer :: rhoi, rhosw
      real(kind=RKIND) :: cste
      type (block_type), pointer :: block
      type (mpas_pool_type), pointer :: geometryPool, meshPool
      real (kind=RKIND), dimension(:,:), pointer :: TFocean
      real (kind=RKIND), dimension(:), pointer :: zOcean
      real (kind=RKIND), dimension(:), pointer :: TFdraft
      real (kind=RKIND), dimension(:), pointer :: deltaT
      real (kind=RKIND), dimension(:), pointer :: ismip6shelfMelt_offset
      integer, dimension(:), pointer :: basinNumber
      real (kind=RKIND), dimension(:), pointer :: lowerSurface
      real (kind=RKIND), dimension(:), pointer :: areaCell
      real (kind=RKIND), dimension(:), allocatable :: mean_TF, IS_area
      integer, parameter :: maxNumBasins = 32
      integer, dimension(:), pointer :: cellMask
      real(kind=RKIND), dimension(maxNumBasins*2) :: localSums, globalSums
      real (kind=RKIND), pointer :: gamma0
      real (kind=RKIND), dimension(:), pointer :: floatingBasalMassBal
      real (kind=RKIND) :: coef
      integer :: i

      err = 0

      call mpas_pool_get_config(liConfigs, 'config_ice_density', rhoi)
      call mpas_pool_get_config(liConfigs, 'config_ocean_density', rhosw)
      cste = (rhosw*cp_seawater/(rhoi*latent_heat_ice))**2  ! in K^(-2)

      allocate(mean_TF(maxNumBasins))
      allocate(IS_area(maxNumBasins))

      block => domain % blocklist
      do while (associated(block))
         call mpas_pool_get_subpool(block % structs, 'geometry', geometryPool)
         call mpas_pool_get_subpool(block % structs, 'mesh', meshPool)

         call mpas_pool_get_dimension(meshPool, 'nCellsSolve', nCellsSolve)
         call mpas_pool_get_dimension(meshPool, 'nISMIP6OceanLayers', nOceanLayers)

         ! Get 3d thermal forcing (had to be read-in)
         call mpas_pool_get_array(geometryPool, 'ismip6shelfMelt_3dThermalForcing', TFocean)

         ! Get z-coords for ocean data
         call mpas_pool_get_array(geometryPool, 'ismip6shelfMelt_zOcean', zOcean)

         ! Get basin numbers
         call mpas_pool_get_array(geometryPool, 'ismip6shelfMelt_basin', basinNumber)

! NOTE: Would need to do a global max for this check to work
!         if (maxval(basinNumber)+1 > maxNumBasins) then
!            call mpas_log_write("Field ismip6shelfMelt_basin contains a value greater than the hard-coded value" // &
!               "for maxNumBasins in iceshelf_melt_ismip6.  Please adjust maxNumBasins and recompile or correct input data.", &
!               MPAS_LOG_ERR)
!         end if

         ! Get shelf draft and mask
         call mpas_pool_get_array(geometryPool, 'lowerSurface', lowerSurface)
         call mpas_pool_get_array(geometryPool, 'cellMask', cellMask)
         call mpas_pool_get_array(meshPool, 'areaCell', areaCell)

         ! Get TFdraft field that we will calculate
         call mpas_pool_get_array(geometryPool, 'ismip6shelfMelt_TFdraft', TFdraft)

         mean_TF(:) = 0.d0
         IS_area(:) = 0.d0

         do iCell = 1, nCellsSolve

            if ( li_mask_is_floating_ice(cellMask(iCell)) ) then
               ! 1 -  Linear interpolation of the thermal forcing on the ice draft depth :
               ksup=1
               do kk=2,nOceanLayers-1
                  if ( zOcean(kk) >= lowerSurface(iCell) )  ksup = kk
               enddo
               kinf = ksup + 1
               if ((zOcean(ksup)-zOcean(kinf)) == 0) then
                  call mpas_log_write("iceshelf_melt_ismip6: Invalid value for zOcean. " // &
                       "ksup=$i kinf=$i zOcean(ksup)=$r zOcean(kinf)=$r iCell=$i lowerSurface=$r", MPAS_LOG_ERR, &
                       intArgs=(/ksup, kinf, iCell/), &
                       realArgs=(/zOcean(ksup), zOcean(kinf), lowerSurface(iCell) /) )
                  err = ior(err, 1)
               endif
               !call mpas_log_write("kinf=$i, zOcean(kinf)=$r, TFocean=$r",realArgs=(/zOcean(kinf),TFocean(kinf,iCell)/), &
               !        intArgs=(/kinf/))
               !call mpas_log_write("ksup=$i, zOcean(ksup)=$r, TFocean=$r",realArgs=(/zOcean(ksup),TFocean(ksup,iCell)/), &
               !        intArgs=(/ksup/))
               TFdraft(iCell) = ( (zOcean(ksup)-lowerSurface(iCell)) * TFocean(kinf, iCell) &
                  + (lowerSurface(iCell)-zOcean(kinf)) * TFocean(ksup, iCell) ) / (zOcean(ksup)-zOcean(kinf))

               ! 2 -  Mean Thermal forcing in individual basins (NB: fortran norm while basins start at zero):
               mean_TF(basinNumber(iCell)+1) = mean_TF(basinNumber(iCell)+1) + areaCell(iCell) * TFdraft(iCell)
               IS_area(basinNumber(iCell)+1) = IS_area(basinNumber(iCell)+1) + areaCell(iCell)

            else
               TFdraft(iCell) = 0.d0
            endif
         enddo

         block => block % next
      enddo   ! associated(block)

      ! global sum mean_TF and IS_area
      localSums(1:maxNumBasins) = mean_TF(:)
      localSums(maxNumBasins+1:2*maxNumBasins) = IS_area(:)
      call mpas_dmpar_sum_real_array(domain % dminfo, 2*maxNumBasins, localSums(:), globalSums(:))
      mean_TF(:) = globalSums(1:maxNumBasins)
      IS_area(:) = globalSums(maxNumBasins+1:2*maxNumBasins)
      do i = 1, maxNumBasins
         if (IS_area(i) > 0.0_RKIND) then
            mean_TF(i) = mean_TF(i) / IS_area(i) ! actual mean TF per basin
            call mpas_log_write("basin=$i, mean_TF=$r", intArgs=(/i-1/), realArgs=(/mean_TF(i)/))
         else ! avoid divide by zero for invalid indices
            mean_TF(i) = 0.0_RKIND
         endif
      enddo


      ! Now calculate melt rate
      block => domain % blocklist
      do while (associated(block))
         call mpas_pool_get_subpool(block % structs, 'geometry', geometryPool)
         call mpas_pool_get_subpool(block % structs, 'mesh', meshPool)

         call mpas_pool_get_dimension(meshPool, 'nCellsSolve', nCellsSolve)

         call mpas_pool_get_array(geometryPool, 'ismip6shelfMelt_gamma0', gamma0)
         call mpas_pool_get_array(geometryPool, 'ismip6shelfMelt_basin', basinNumber)
         call mpas_pool_get_array(geometryPool, 'ismip6shelfMelt_TFdraft', TFdraft)
         call mpas_pool_get_array(geometryPool, 'ismip6shelfMelt_deltaT', deltaT)
         call mpas_pool_get_array(geometryPool, 'ismip6shelfMelt_offset', ismip6shelfMelt_offset)
         call mpas_pool_get_array(geometryPool, 'floatingBasalMassBal', floatingBasalMassBal)
         call mpas_pool_get_array(geometryPool, 'cellMask', cellMask)

         call mpas_log_write("iceshelf_melt_ismip6: gamma0=$r", realArgs=(/gamma0/))
         floatingBasalMassBal(:) = 0.0_RKIND
         coef = gamma0 * cste / scyr * rhoi
         do iCell = 1, nCellsSolve
            if ( li_mask_is_floating_ice(cellMask(iCell)) ) then
               floatingBasalMassBal(iCell) = -1.0_RKIND * coef * (TFdraft(iCell) + deltaT(iCell)) * &
                  abs(mean_TF(basinNumber(iCell)+1) + deltaT(iCell)) + ismip6shelfMelt_offset(iCell)
            endif
         enddo

         block => block % next
      enddo   ! associated(block)

      deallocate(mean_TF)
      deallocate(IS_area)

    end subroutine iceshelf_melt_ismip6
!-----------------------------------------------------------------------

!-----------------------------------------------------------------------

!|||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||
!
!  !  routine grounded_face_melt_ismip6
!
!> \brief Calculate grounded glacier submarine melt rate using parameterization from ISMIP6
!> \author Trevor Hillebrand
!> \date   April 2020
!> \details
!> http://www.climate-cryosphere.org/wiki/index.php?title=ISMIP6-Projections-Greenland
!> https://www.the-cryosphere.net/14/985/2020/tc-14-985-2020.pdf
!> https://agupubs-onlinelibrary-wiley-com.lanl.idm.oclc.org/doi/full/10.1002/2016GL068784
!> Melt parameterization of the form:
!> melt_rate = (A * h * q_sg^alpha + B) * TF^beta
!> where TF is local thermal forcing at each grid cell, h is water depth at ice front  
!> q_sg is subglacial water glux in m/day. Default values A = 3e-4, alpha = 0.39, B = 0.15
!> beta=1.18
!-----------------------------------------------------------------------


    subroutine grounded_face_melt_ismip6(domain, err)

      use li_calving  
      !-----------------------------------------------------------------
      ! input variables
      !-----------------------------------------------------------------
      type (domain_type), intent(inout) :: &
         domain          !< Input/Output: domain object
 
      !-----------------------------------------------------------------
      ! output variables
      !-----------------------------------------------------------------
      integer, intent(out) :: err

      !-----------------------------------------------------------------
      ! local variables
      !-----------------------------------------------------------------
      integer :: iCell, iNeighbor, iEdge, nEmptyNeighbors
      real (kind=RKIND), pointer :: rhoi
      integer, pointer :: nCellsSolve, nEdgesSolve, maxEdges
      integer, dimension(:,:), pointer :: cellsOnEdge, cellsOnCell, edgesOnCell
      real (kind=RKIND) :: waterDepth, submergedFaceArea, oceanEdgeLength
      type (block_type), pointer :: block
      type (mpas_pool_type), pointer :: geometryPool, meshPool, scratchPool, velocityPool
      real (kind=RKIND), pointer :: seaLevel
      real (kind=RKIND), pointer :: deltat
      real (kind=RKIND), dimension(:), pointer :: dvEdge
      real (kind=RKIND), dimension(:), pointer :: thickness, lowerSurface, meltingThickness
      real (kind=RKIND), dimension(:), pointer :: bedTopography
      real (kind=RKIND), dimension(:), pointer :: TFocean, ismip6Runoff
      real (kind=RKIND), dimension(:), pointer :: areaCell
      integer, dimension(:), pointer :: cellMask, edgeMask, nEdgesOnCell
      real (kind=RKIND), dimension(:), pointer :: calvingVelocity
      real (kind=RKIND), pointer :: aSubglacial ! param A
      real (kind=RKIND), pointer :: alphaSubglacial ! param alpha
      real (kind=RKIND), pointer :: B ! param B
      real (kind=RKIND), pointer :: betaTF ! param beta
      real (kind=RKIND), pointer :: addTFocean ! adjust ocean thermal forcing
      real (kind=RKIND), pointer :: config_uniform_face_melt_rate
      real (kind=RKIND), parameter :: secPerDay = 86400.0
      real (kind=RKIND), parameter :: rhow = 1000.0 ! subglacial runoff density
      integer, dimension(:), pointer :: groundedMarineMarginMask
      real (kind=RKIND), dimension(:), pointer :: faceMeltRateApplied, faceMeltSpeed
      integer :: err_tmp
      logical :: applyToFloating, applyToGrounded, applyToGroundingLine
      logical :: applyMelting, applyCalving
       
      err = 0
      call mpas_log_write('Starting face melt routine')

      ! Define logicals for call to apply_front_ablation_velocity
      applyToFloating = .false. ! if true, only apply to floating ice
      applyToGrounded = .false.  ! if true, only apply to grounded
      applyToGroundingLine = .true. ! if true, apply at grounding line
      applyMelting = .true.
      applyCalving = .false.

      ! Get sea level, bedTopography, ice density
      call mpas_pool_get_config(liConfigs, 'config_ice_density', rhoi)
      call mpas_pool_get_config(liConfigs, 'config_sea_level', seaLevel)
      
      ! Get melt parameters
      call mpas_pool_get_config(liConfigs, 'config_beta_ocean_thermal_forcing', betaTF)
      call mpas_pool_get_config(liConfigs, 'config_alpha_subglacial_discharge', alphaSubglacial)
      call mpas_pool_get_config(liConfigs, 'config_subglacial_discharge_coefficient', aSubglacial)
      call mpas_pool_get_config(liConfigs, 'config_subglacial_discharge_intercept', B)
      call mpas_pool_get_config(liConfigs, 'config_add_ocean_thermal_forcing', addTFocean)
      call mpas_pool_get_config(liConfigs, 'config_uniform_face_melt_rate', config_uniform_face_melt_rate)
      
      block => domain % blocklist
      do while (associated(block))
         call mpas_pool_get_subpool(block % structs, 'geometry', geometryPool)
         call mpas_pool_get_subpool(block % structs, 'mesh', meshPool)
         call mpas_pool_get_subpool(block % structs, 'scratch', scratchPool)
         call mpas_pool_get_subpool(block % structs, 'velocity', velocityPool)
         call mpas_pool_get_dimension(meshPool, 'nCellsSolve', nCellsSolve)
         call mpas_pool_get_dimension(meshPool, 'nEdgesSolve', nEdgesSolve)
         call mpas_pool_get_dimension(meshPool, 'maxEdges', maxEdges)
         ! Get ISMIP6 forcing fields
         call mpas_pool_get_array(geometryPool, 'ismip6_2dThermalForcing', TFocean) 
         call mpas_pool_get_array(geometryPool, 'ismip6Runoff', ismip6Runoff)
         call mpas_pool_get_array(geometryPool, 'calvingVelocity', calvingVelocity)
        
         ! Get mesh and geometry arrays
         call mpas_pool_get_array(geometryPool, 'cellMask', cellMask)
         call mpas_pool_get_array(geometryPool, 'edgeMask', edgeMask)
         call mpas_pool_get_array(meshPool, 'areaCell', areaCell)
         call mpas_pool_get_array(meshPool, 'dvEdge', dvEdge)
         call mpas_pool_get_array(meshPool, 'areaCell', areaCell)
         call mpas_pool_get_array(meshPool, 'nEdgesOnCell', nEdgesOnCell)
         call mpas_pool_get_array(meshPool, 'cellsOnCell', cellsOnCell)
         call mpas_pool_get_array(meshPool, 'edgesOnCell', edgesOnCell)
         call mpas_pool_get_array(meshPool, 'cellsOnEdge', cellsOnEdge)
         call mpas_pool_get_array(geometryPool, 'thickness', thickness)
         call mpas_pool_get_array(geometryPool, 'meltingThickness', meltingThickness)
         call mpas_pool_get_array(geometryPool, 'bedTopography', bedTopography)
         call mpas_pool_get_array(geometryPool, 'lowerSurface', lowerSurface) 
         call mpas_pool_get_array(geometryPool, 'groundedMarineMarginMask', groundedMarineMarginMask)
         call mpas_pool_get_array(geometryPool, 'faceMeltRateApplied', faceMeltRateApplied)
         call mpas_pool_get_array(geometryPool, 'faceMeltSpeed', faceMeltSpeed)
         call mpas_pool_get_array(meshPool, 'deltat', deltat)

         faceMeltRateApplied(:) = 0.0_RKIND
         faceMeltSpeed(:) = 0.0_RKIND 
       ! Calculate retreat rate for each cell
         do iCell = 1, nCellsSolve
            ! Define marine marginal cells as those that are (1) at the ice
            ! margin, (2) have at least one neighboring cell without ice, (3) contain
            ! grounded ice, and (4) have bed topography below sea level.
            ! OR is adjacent to an inactive floating margin cell
            oceanEdgeLength = 0.0_RKIND
            
            ! Calculate length of grounding line for each cell
            if ( bedTopography(iCell) < seaLevel &
                .and. li_mask_is_grounded_ice(cellMask(iCell)) ) then
               do iEdge = 1, nEdgesOnCell(iCell)
                 iNeighbor = cellsOnCell(iEdge, iCell)
                 if ( li_mask_is_grounding_line(edgeMask(edgesOnCell(iEdge,iCell))) ) then 
                    oceanEdgeLength = oceanEdgeLength + dvEdge(edgesOnCell(iEdge, iCell))
                 endif
               enddo 
            endif
            
            if ( bedTopography(iCell) < 0.0_RKIND ) then
                waterDepth = seaLevel - bedTopography(iCell)
            else
                waterDepth = 0.0
            endif
           
            submergedFaceArea = waterDepth * oceanEdgeLength
                
            if (config_uniform_face_melt_rate == 0.0) then                
                ! Calculate ice front melt rate at each cell
               faceMeltSpeed(iCell) = (aSubglacial * waterDepth * & ! m s^-1
                         (ismip6Runoff(iCell) / rhow * secPerDay)**alphaSubglacial &
                         + B) * max(0.0_RKIND, TFocean(iCell) + addTFocean)**betaTF / secPerDay
            else
               faceMeltSpeed(iCell) = config_uniform_face_melt_rate
            endif

         enddo

         call mpas_log_write("calling apply_front_ablation_velocity")
         ! Distribute melt among neighbors
       !  call distribute_face_melt_flux(meshPool, geometryPool, scratchPool, groundedMarineMarginMask, err_tmp)
         call apply_front_ablation_velocity(meshPool, geometryPool, velocityPool, applyToGrounded, &
                                            applyToFloating, applyToGroundingLine, applyCalving, &
                                            applyMelting, domain, err)

         call mpas_log_write("Back to melting routine")

         ! Apply facemelt: open the Ark
         thickness(:) = thickness(:) - meltingThickness(:)
         faceMeltRateApplied = meltingThickness(:) * areaCell(:) / deltat

         ! update mask
         call li_calculate_mask(meshPool, velocityPool, geometryPool, err_tmp)
         err = ior(err, err_tmp)

         block => block % next
      enddo    ! associated(block)

    end subroutine grounded_face_melt_ismip6
!-----------------------------------------------------------------------

!-----------------------------------------------------------------------
!|||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||
!
!  !  routine distribute_face_melt_flux
!
!> \brief Applies a specified melt rate along a grounded marine margin
!> \author Trevor Hillebrand, Matthew Hoffman
!> \date   April 2020
!> \details Applied a specific melt rate along a grounded marine margin. 
!> This is based on distribute_calving_flux subroutine in mpas_li_calving.F
!> and adapted for grounded ice.
!> The melt rate (faceMeltRateApplied) is calculated in subroutine grounded_face_melt_ismip6.
!> The melt volume needs to be distributed in three ways:
!> 1. We need to first remove any "thin" ice in front of this cell
!> 2. Then we remove ice from this cell
!> 3. If there is still additional ice to be removed, we have to recursively
!>    remove ice "inland" of this cell until the total required mass is removed
!-----------------------------------------------------------------------

   subroutine distribute_face_melt_flux(meshPool, geometryPool, scratchPool, groundedMarineMarginMask, err)


      !-----------------------------------------------------------------
      ! input variables
      !-----------------------------------------------------------------
      type (mpas_pool_type), pointer, intent(in) :: meshPool !< Input: Mesh pool
      type (mpas_pool_type), pointer, intent(in) :: scratchPool !< Input: scratch pool
      integer, dimension(:), intent(in) :: groundedMarineMarginMask

      !-----------------------------------------------------------------
      ! input/output variables
      !-----------------------------------------------------------------
      type (mpas_pool_type), pointer, intent(inout) :: geometryPool !< Input: geometry pool

      !-----------------------------------------------------------------
      ! output variables
      !-----------------------------------------------------------------
      integer, intent(out) :: err !< Output: error flag

      !-----------------------------------------------------------------
      ! local variables
      !-----------------------------------------------------------------
      real (kind=RKIND), dimension(:), pointer :: faceMeltRateApplied, meltingThickness, &
                                                  thickness, areaCell, cellVolume, &
                                                  unmeltedVolume, bedTopography                                
      real (kind=RKIND), pointer :: deltat
      integer, dimension(:), pointer :: nEdgesOnCell, cellMask
      integer, dimension(:,:), pointer :: cellsOnCell
      integer, pointer :: nCells
      integer :: unmeltedCount, inwardNeighbors, iCell, iNeighbor, jCell
      real (kind=RKIND) :: volumeLeft, removeVolumeHere, unmeltedTotal
      type (field1dReal), pointer :: cellVolumeField

      err = 0

      ! get fields
      call mpas_pool_get_dimension(meshPool, 'nCells', nCells)
      call mpas_pool_get_array(meshPool, 'deltat', deltat)
      call mpas_pool_get_array(geometryPool, 'cellMask', cellMask)
      call mpas_pool_get_array(geometryPool, 'thickness', thickness)
      call mpas_pool_get_array(geometryPool, 'meltingThickness', meltingThickness)
      call mpas_pool_get_array(geometryPool, 'faceMeltRateApplied', faceMeltRateApplied)
      call mpas_pool_get_array(geometryPool, 'unmeltedVolume', unmeltedVolume)
      call mpas_pool_get_array(geometryPool, 'bedTopography', bedTopography)
      call mpas_pool_get_array(meshPool, 'nEdgesOnCell', nEdgesOnCell)
      call mpas_pool_get_array(meshPool, 'cellsOnCell', cellsOnCell)
      call mpas_pool_get_array(meshPool, 'areaCell', areaCell)

      call mpas_pool_get_field(scratchPool, 'workCell',  cellVolumeField)
      call mpas_allocate_scratch_field(cellVolumeField, .true.)
      cellVolume => cellVolumeField % array

      meltingThickness(:) = 0.0_RKIND
      unmeltedVolume(:) = 0.0_RKIND

      cellVolume(:) = areaCell(:) * thickness(:)

      do iCell = 1, nCells
         if (groundedMarineMarginMask(iCell) == 1) then
            volumeLeft = faceMeltRateApplied(iCell) * deltat  ! units m^3

            ! First remove ice from "thin" neighbors
            do iNeighbor = 1, nEdgesOnCell(iCell)
               jCell = cellsOnCell(iNeighbor, iCell)
               if (li_mask_is_floating_ice(cellMask(jCell)) .and. .not. li_mask_is_dynamic_ice(cellMask(jCell))) then
                  ! this is a thin neighbor - remove as much ice from here as we
                  ! can
                  ! TODO: could distribute this evenly amongst neighbors
                  removeVolumeHere = min(volumeLeft, cellVolume(jCell)) ! how much we want to remove here
                  meltingThickness(jCell) = meltingThickness(jCell) + removeVolumeHere / areaCell(jCell)
                      ! < apply to the field that will be used, in thickness
                      ! units
                  cellVolume(jCell) = cellVolume(jCell) - removeVolumeHere ! update accounting on cell volume
                  volumeLeft = volumeLeft - removeVolumeHere ! update accounting on how much left to distribute from current iCell
               endif
            enddo

            if (volumeLeft > 0.0_RKIND) then
               ! Now remove ice from iCell
               removeVolumeHere = min(volumeLeft, cellVolume(iCell))
               meltingThickness(iCell) = meltingThickness(iCell) + removeVolumeHere / areaCell(iCell)
                  ! < apply to the field that will be used in thickness units
               cellVolume(iCell) = cellVolume(iCell) - removeVolumeHere ! update accounting on cell volume
               volumeLeft = volumeLeft - removeVolumeHere ! update accounting on how much left to distribute from current iCell
            endif

            if (volumeLeft > 0.0_RKIND) then
               ! Now remove ice from neighbors inland of margin;
               ! first count up how many there are
               inwardNeighbors = 0
               do iNeighbor = 1, nEdgesOnCell(iCell)
                  jCell = cellsOnCell(iNeighbor, iCell)
                  if  ( li_mask_is_dynamic_ice(cellMask(jCell)) .and. (.not. li_mask_is_dynamic_margin(cellMask(jCell))) &
                        .and. bedTopography(jCell) < 0.0_RKIND ) then
                     inwardNeighbors = inwardNeighbors + 1
                  endif
               enddo

               ! Now distribute the flux evenly amongst the neighbors
               do iNeighbor = 1, nEdgesOnCell(iCell)
                  jCell = cellsOnCell(iNeighbor, iCell)
                  if ( li_mask_is_dynamic_ice(cellMask(jCell)) .and. (.not. li_mask_is_dynamic_margin(cellMask(jCell))) &
                        .and. bedTopography(jCell) < 0.0_RKIND ) then
                     ! this is thick neighbor that is not itself a margin -
                     ! remove as much ice from here as we can
                     removeVolumeHere = min(volumeLeft / real(inwardNeighbors, kind=RKIND), cellVolume(jCell))
                        ! < how much we want to remove here
                     meltingThickness(jCell) = meltingThickness(jCell) + removeVolumeHere / areaCell(jCell)
                        ! < apply to the field that will be used in thickness
                        ! units
                     cellVolume(jCell) = cellVolume(jCell) - removeVolumeHere ! update accounting on cell volume
                     volumeLeft = volumeLeft - removeVolumeHere
                        ! < update accounting on how much left to distribute
                        ! from current iCell
                  endif
               enddo
               !TODO: need to recursively distribute across neighbors until
               !fully depleted :(
            endif

            ! If we didn't melt enough ice, record that to allow assessment of    
            ! how bad that is.
            if (volumeLeft > 0.0_RKIND) then
               unmeltedVolume(iCell) = 0.0_RKIND
            endif
         endif ! if cell is melting margin
      enddo ! cell loop
      if (maxval(unmeltedVolume) > 0.0_RKIND) then
         unmeltedTotal = sum(unmeltedVolume)
         unmeltedCount = count(unmeltedVolume > 0.0_RKIND)
         call mpas_log_write("distribute_face_melt_flux failed to distribute all required melt - " // &
                    " ice was left after depleting all neighbors." // &
                    "  Search needs to be expanded to neighbors' neighbors.")
         call mpas_log_write("   On this processor: $i cells contain unmelted ice, " // &
                 "for a total unmelted volume of $r m^3 ($r%).", &
                 MPAS_LOG_WARN, intArgs=(/unmeltedCount/), &
                 realArgs=(/unmeltedTotal, 100.0_RKIND * unmeltedTotal/(faceMeltRateApplied(iCell) * deltat)/))
      endif
      call mpas_deallocate_scratch_field(cellVolumeField, .true.)

   end subroutine distribute_face_melt_flux
!-----------------------------------------------------------------------

  !***********************************************************************
  end module li_iceshelf_melt

!|||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||


